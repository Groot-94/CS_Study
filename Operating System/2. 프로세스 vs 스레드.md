# 2. 프로세스 vs 스레드

## 프로세스
- 정의
    - 실행 중인 프로그램
    - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
    - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 특징
    - 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받음
    - 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드) 보유
    - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근불가
        - 한 프로세스가 다른 프로세스의 자원에 접근하려면 
            - 프로세스 간의 통신(IPC, inter-process communication) 사용
            - LPC(Local inter-Process Comunicatin)사용
            - 별도로 공유 메모리를 만들어 정보를 주고받도록 설정
        - 위의 3가지 방법은 CPU 레지스터 교체뿐만 아니라, RAM과 CPU 사이의 캐시 메모리까지 초기화되므로 자원 부담이 큼

## 프로세스의 문맥(Context)

![](https://i.imgur.com/OCHt8YG.png)

- 정의
    - 프로세스의 현재 상태를 나타내는 모든 요소
    - 프로그램이 어디까지 어떻게 실행되었고, 현재 어떤 상태에 있는지 설명하기 위하여 사용하는 개념
        - 실행 시, 프로세스의 독자적인 주소 공간 생성
        - stack, data, code, heap로 구성
        - 담겨 있는 정보
            - 프로그램 카운터가 어딜 가리키고 있는가
            - 코드의 어느부분까지 실행했는가
            - 메모리에 어떤 내용을 담고 있는가
            - 코드 실행시 함수 호출에 의해 스택에 어떤 내용을 쌓아놓았는가
            - data에 담긴 변수는 어떻게 변경되었는가
            - register에 어떤 값을 넣어놓고, 어떤 인스트럭션까지 실행했는가
            - ...
- 종류
    - 하드웨어 문맥
        - `CPU` 수행 상태 나타냄
        - Program Counter
        - 각종 레지스터
    - 프로세스 주소 공간
        - `메모리` 관련
        - CODE, DATA, STACK, HEAP
    - 프로세스 관련 커널 자료 구조
        - 운영체제가 프로세스 관리 역할
        - PCB(Process Control Block)
        - Kernel Stack
            
- 필요성
    - 현대 컴퓨터 시스템은 time sharing, multi tasking 등 프로세스가 번갈아 실행되기 때문에 현재 문맥을 알지 못하면 다음번 cpu를 잡았을 때 앞부분부터 다시 실행해야 하는 문제 발생 가능

> #### Program Counter
> 프로세스 내부에 있는 레지스터 중 하나
다음에 실행될 명령어의 주소를 가지고 있어 명령어 포인터라고도 함
각 명령어 사이클에 따라 자동적으로 증가하여, 메모리에 있는 명령어들이 순차적으로 실행될 수 있도록 함

> #### PCB(Process Control Block)
> 프로세스 시작될 때마다, 운영체제는 프로세스 관리를 위해 자신의 data 영역에 자료 구조(PCB)를 할당

> #### Kernel Stack
> 각 프로세스가 자기 자신의 코드를 실행중일 때, 함수 호출이 이루어지면 스택에 관련 정보를 쌓음. 
> 그런데 프로세스가 실행되다 본인이 할 수 없는 일을 운영체제에게 대신 해달라 요청 가능(=시스템 콜) 
> 시스템 콜을 하게 되면 프로그램 카운터가 프로세스의 주소 공간이 아닌 커널의 주소공간의 코드를 가리킴. 
커널에서 함수 호출 이루어지면 커널의 스택에 관련 정보 쌓음. 
커널은 여러 프로세스들이 공유하는 코드, 즉 어떤 프로세스 간에 운영체제한테 요청을 할 때 서비스를 해달라고 부탁할때, 커널 코드 실행. 
프로세스별로 커널 스택을 별도로 두어, 정보가 꼬이는 문제를 막음.
        프로세스의 현재 상태를 규정하기 위해서는 유저 스택이 아닌 커널 스택의 정보 필요

## 프로세스의 상태(Process State)
- 프로세스는 상태(state)가 변경되며 수행
- 종류
    - Running
        - CPU를 잡고 instruction을 수행중인 상태
    - Ready
        - CPU를 기다리는 상태
        - (메모리 등 다른 조건을 모두 만족한 상태 가정)
    - Blocked(wait, sleep)
        - CPU를 주어도 당장 instruction을 수행할 수 없는 상태(오랜 작업에 해당)
        - Process 자신이 요청한 event(예: I/O)가 즉시 만족되지 않아 이를 기다리는 상태
        - 예시) 디스크에서 file을 읽어와야 하는 경우
    - New
        - 프로세스가 생성중인 상태
    - Terminated
        - 수행(execution)이 끝난 상태 
    - Suspended(stopped)
        - 외부적인 이유로 프로세스의 수행이 정지된 상태
        - 프로세스는 통째로 디스크에 swap out 됨
            - 예시) 사용자가 프로그램을 일시 정지시킨 경우(break key)
                - 시스템이 여러 이유로 프로세스를 잠시 중단 시킴
                - 메모리에 너무 많은 프로세스가 올라와 있을때
> #### Blocked vs Suspended
> Blocked => 자신이 요청한 event가 만족되면 Ready
> Supsended => 외부에서 resume해주어야 Active
        
- 요약
    - 상황: A 회사에서 맥북을 통해 일을 할 때
    - A 회사에서 맥북(CPU)을 받아 일을 하면 running
    - A 회사에서 출근하여 일 할 준비는 되었는데 맥북을 못 받았으면 ready
    - A 회사에서 출근하여 맥북을 사용하기 위하여 전산실에 신청을 하는 등 오래걸리는 작업을 하는 경우 Blocked
        - 신청이 완료되어 맥북을 받는다면 ready
    - A 회사에서 갑자기 맥북 부족하다고 맥북 뺏어가서 아무 일도 할 수 없으면 Suspended
        - 외부에서 맥북 다시 돌려받아야 Active
- 프로세스 상태도
![](https://i.imgur.com/u2DJ6fz.png)

## PCB(Process Control Block)

- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
![](https://i.imgur.com/UDQyZi7.png)
- 구성요소
    1) OS가 관리상 사용하는 정보
        - Process state, Process ID
        - scheduling information, priority
    2) CPU 수행 관련 하드웨어 값
        - Program counter, registers
    3) 메모리 관련
        - Code, Data, Stack, Heap의 위치 정보
    4) 파일 관련
        - Open file descriptors...
        
## 문맥 교환(Context Switch)
- 정의
    - CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
        - CPU는 빠른 자원
        - 어떤 프로세스가 CPU를 장악해 계속 사용 X
        - 짧은 시간 간격으로 CPU를 얻었다가 뺏겼다가 반복
        - CPU를 뺏겼다가 다시 시작시, 처음부터가 아닌 뺏겼던 시점의 문맥을 기억했다가 그 시점부터 계속해서 실행될 수 있게!
- 진행과정
    ![](https://i.imgur.com/vexeUbY.png)
    - CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행
        - CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
        - CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
    
- 주의점
    - System Call이나 Interrupt 발생시, 반드시 context switch가 일어나는 것은 아님
        ![](https://i.imgur.com/0ikJG0O.png)
        - System Call은 프로세스가 본인이 필요해서 운영체제에게 뭔가를 요청할 때 발생
        - Interrupt은 컨트롤러 같은 장치가 CPU에게 정보 전달을 목적으로 인터럽트를 걺
        - System Call 혹은 Interrupt 발생시, CPU 제어권이 `사용자` 프로세스로부터 `운영체제 커널`로 넘어감
        - `사용자 프로세스 -> 운영체제 커널`로 넘어가는 것을 Context Switch라고 부르는 것이 아님!
        - `사용자 프로세스 -> 또 다른 사용자 프로세스`로 넘어가는 과정이 Context Switch
        - timer interrupt는 CPU를 다른 프로세스에게 넘기려는 의도가 담긴 인터럽트
        - I/O 같은 오래걸리는 작업은 요청이 끝나고 CPU를 줘봤자 instruction 실행이 불가능하므로, 또다른 ready 상태의 프로세스에게 넘겨줌
        - 1번의 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 save해야 하지만, 문맥교환을 하는 2번의 경우 그 부담이 훨씬 큼
            - 예시) cache memory flush
                - 문맥 교환이 이루어지면 대체로 cache memory를 다 지워버려야 함
                - 1)의 상태에서는 그 정도는 필요없음!
                - cache memory flush는 막강한 overhead 발생

## 프로세스 스케쥴링을 위한 큐(queue)

- 프로세스들은 각 큐들을 오가며 수행
- 종류
    - Job queue
        - 현재 시스템 내에 있는 모든 프로세스의 집합
        - Ready Queue에 있는 것이 Job queue에 있을 수 있지만, Device queue에 있을 수는 없음
    - Ready queue
        - CPU를 기다리는 줄
        - 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
    - Device queue
        - I/O device의 처리를 기다리는 프로세스의 집합

- Ready Queue와 다양한 Device Queue 예시
![](https://i.imgur.com/zR5F1UG.png)

- 진행과정
![](https://i.imgur.com/7RD8Mjh.png)
    - 프로세스 시작
    - Ready Queue에 대기
    - 언젠가 CPU를 얻음
    - CPU를 계속 쓰고 싶지만 할당 시간이 끝나면 다시 Ready Queue에 줄 서야 함
        - 오래 걸리는 작업시, 오래 걸리는 작업의 큐에 대기했다가, 그 작업이 끝나면, 다시 CPU를 얻을 수 있는 ready Queue에 대기
        - 인터럽트의 경우 정확히는 ready queue에 넘어가는 것은 아니기 때문에 유의
        
## 스케줄러(Scheduler)
- 종류
    - Long-term scheduler(장기 스케줄러 or job scheduler)
        - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
        - 프로세스에 "memory"(및 각종 자원)을 주는 문제
            - 어떤 프로세스가 new 상태에 있는데 그것에 메모리를 줄지 안 줄지 결정
        - degree of Multiprogramming을 제어
            - 멀티프로그래밍은 메모리에 여러 프로그램이 동시에 올라가는 개념
            - 메모리에 프로그램이 몇개 올라가 있는가를 나타냄
            - 메모리에 올라간 프로세스의 수를 제어하는 것이 Long-term scheduler의 역할
            - 메모리에 너무 많은 프로그램이 동시에 올라가면 성능이 안 좋아짐
                - 너무 많이 올리면, CPU를 잡고 프로그램을 실행하려고 했는데, 당장 필요한 부분마저 메모리에 안 올라와있을 수 있음
                - 각 프로그램이 메모리를 조금밖에 안 가지고 있어 다시 I/O 하러 가야함
            - 너무 적어도 마찬가지
                - 메모리에 프로그램이 하나면, 그 프로그램이 CPU를 쓰다가 I/O를 하러가면 CPU는 놀게 됨
            
        - time sharing system에는 보통 장기 스케줄러가 없음(무조건 ready)
            - 장기스케줄러 부재시 degree of multiprogramming 제어를 위해서 Medium-Term Scheduler 사용
    - Short-term scheduler(단기 스케줄러 or CPU scheduler)
        - 어떤 프로세스를 다음번에 running 시킬지 결정
        - 프로세스에 "CPU"를 주는 문제
        - 충분히 빨라야 함(millisecond 단위)
    - Medium-Term Scheduler(중기 스케줄러 or Swapper)
        - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
        - 프로세스에게서 "memory"를 뺏는 문제
        - degree of Multiprogramming을 제어
        - 기존의 프로세스의 상태(running, ready, blocked)에 Suspended가 추가됨
        ![](https://i.imgur.com/9VKGNwy.png)

- Thread
- 배경
    - 과거 프로그램은 실행 시작부터 끝까지 프로세스 하나만을 사용하여 진행
    - 프로그램이 복잡해지면서 프로세스 하나만으로 벅참
        - 프로그램이 단순히 한가지 작업만을 하는 시대가 지남
    - 하나의 프로그램을 처리하기 위하여 프로세스를 여러개 프로세스 사용시
        - 운영체제는 안정성을 위해 프로세스마다 자신에게 할당된 메모리 내의 정보에만 접근 가능하도록 제약 설정
        - 이를 벗어나면 오류 발생
        - 이러한 한계를 극복하기 위해 등장한 쓰레드
- 정의
    - 프로세스 내부에 CPU 수행단위가 여러 개 있는 경우, 쓰레드라고 칭함
    - 프로세스의 특정한 수행 경로
    - 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 특징
    ![](https://i.imgur.com/PDGC5ad.png)
    - CPU 수행을 위해서는(instruction을 실행하려면) code의 어느 부분을 수행하고 있는지 가리키는 program counter가 있어야 하고, CPU에 실행되면서 register 값들을 설정하고 실행하고 있음. 
    - 각 스레드(CPU 수행단위)마다 레지스트의 어떤 값을 넣고, 프로그램 카운터가 코드 어느 부분을 가리키면서 실행하고 있었는지를 별도로 유지
    - 쓰레드 하나가 코드 어느 부분을 실행하여 함수호출을 하면, 이와 관련한 정보를 스택에 쌓아야 함. 
    - 스레드(CPU 수행단위)가 여러개 있게 되면 스택도 별도로 두어야 함.
    - 스레드는 프로세스 하나에서 공유할 수 있는 것은 최대한 공유
        - 메모리 주소 공간
        - 프로세스는 하나이기 때문에 프로세스 상태도 공유
        - 프로세스가 사용하는 각종 자원도 공유
    - 별도로 갖고 있는 건 CPU 수행과 관련된 정보뿐
        - 프로그램 카운터, 레지스터, 스택
        - 프로세스는 하나기 때문에 PCB를 하나만 생성
        - 프로세스 안에 thread 여러 개면, CPU 수행 관련 정보(program counter, register...)만을 각각 가지게 됨
        ![](https://i.imgur.com/nD2grMk.png)
- 장점
    - 응답성 향상
        - 다중 스레드로 구성된 task 구조에서 하나의 서버 스레드가 blocked(waiting) 상태인 동안에도 동일한 task 내의 다른 스레드가 실행(running)되어 빠른 처리 가능
    - 동일 작업 성능 향상
        - 동일 작업 수행시 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상 가능
        - 동일 작업 하, 별도 프로세스 생성시 메모리 등 자원 낭비
            - 독자적인 주소 공간 생성으로 인한 메모리 차지
    - 자원 공유
        - 동일 작업 하, 별도 스레드로 처리시 code, data, resource 공유
        - 자원 공유를 통한 효율 증가 기대
    - 경제성
        - 생성, CPU Switching 시, 프로세스보다 thread 사용이 overhead가 더 적음
    - 병렬성 향상
        - CPU가 여러 개임을 전제(MP[Multi Processor] Architectures)
        - 예시) 1000 * 1000 행렬 연산시, 
            - 독립적인 연산이기에 CPU 하나면 순차적 실행
            - CPU 여러 개면 각자 실행하고 합쳐주면 더 빠른 결과 산출 가능
- 구현 방법
    - 커널(Kernel Thread)
        - 프로세스 안에 쓰레드가 여러개 있다는 사실을 운영체제 커널이 `알고 있음`
        - 하나의 쓰레드에서 다른 쓰레드로 CPU가 넘어가는 것도 커널이 CPU 스케쥴링 하듯이 넘겨줌
    - 라이브러리(User Thread)
        - 프로세스 안에 쓰레드가 여러개 있다는 사실을 운영체제 커널이 `모름`
        - User Program이 스스로 라이브러리의 지원을 받아 여러 개의 쓰레드를 관리
        - 즉, 커널 지원 받지 않고 사용자 수준에서 thread 구현하면 User Thread
    - 기타
        - real-time thread
- 정리
    - 스레드는 CPU를 수행하는 단위
    - 구성
        - program counter
        - register set
        - stack space
    - 프로세스 내부에서 thread끼리 공유하는 부분(=task)
        - code section
        - data section
        - OS resources
    - 스레드를 lightweight process라고도 부름
        - 프로세스를 별도로 두기 보다, 프로세스 안에 쓰레드를 여러 개 두는 것이 가볍기 때문
        - 전통적인 프로세스는 heavyweight process로 하나의 thread를 가지고 있는 task를 의미


## 프로그램 vs 프로세스 vs 스레드
- 정의 측면
    - 프로그램은 파일이 디스크에 저장되어 있지만, 메모리에는 올라가지 않은 정적인 상태
        - 메모리에 올라가지 않음
            - 운영체제가 프로그램에 독립적인 메모리 공간을 할당해주지 않았음을 의미
            - 모든 프로그램은 운영체제가 실행되기 위한 메모리 공간을 할당해 줘야 실행 가능
        - 정적인 상태
            - 실행되지 않고 가만히 있는 상태
    - 프로세스는 운영체제로부터 자원을 할당받는 "작업"의 단위로, 메모리에 올라간 동적인 상태에 해당
    - 스레드는 할당 받은 자원을 이용하는 "실행"의 단위로, 프로세스 내 여러 개 생성 가능
- 자원 공유 측면
    - 운영체제가 프로세스에게 Code, Data, Stack, Heap 메모리 영역을 할당해주고 최소 작업 단위로 삼는 반면, 스레드는 프로세스 내에서 Stack 메모리 영역을 제외한 다른 메모리 영역을 같은 프로세스 내 다른 스레드와 공유
    - 프로세스는 다른 프로세스와 정보를 공유하려면 IPC를 사용하는 등 번거로운 과정 필요, 스레드는 기본 구조 자체가 메모리를 공유하는 구조이기 때문에 다른 스레드와의 정보 공유 용이
        - 멀티 태스킹보다 멀티스레드가 자원 절약에 효과적
- 스케줄링 측면
    - 스레드의 스케쥴링은 운영체제가 처리하지 않기 때문에  개발자가 직접 동기화 문제에 대응 필요
- 요약
    - 프로그램은 코드 덩어리 파일, 그 프로그램을 실행한 게 프로세스
    - 스레드는 프로세스의 코드에 정의된 절차에 따라 실행되는 특정한 수행 경로
    - 어플리케이션이 하나의 프로세스라면, 그 안에서의 분기처리가 스레드에 해당

## 멀티 프로세스 vs 멀티 스레드
- 멀티 프로세스
    - 정의
        - 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(task)을 처리
    - 장점
        - 여러 개의 자식 프로세스 중 하나에 문제가 발생하여도, 그 자식 프로세스만 죽을 뿐, 프로그램은 정상 작동
    - 단점
        - Context Switching에서의 Overhead
            - 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 시간 소요
                - 프로세스는 각각 독립된 메모리 영역을 할당받았기에, 프로세스 간 공유 메모리가 없어, 캐시에 있는 모든 데이터를 리셋하고 다시 불러와야 함
        - 프로세스 간 어렵고 복잡한 통신 기법
            - 프로세스는 각각 독립된 메모리 영역을 할당받았기 때문에, 하나의 프로그램에 속하는 프로세스들 사이의 변수 공유 불가
- 멀티 스레드
    - 정의
        - 하나의 응용프로그램을 여러 개의 스레드로 구성하고, 각 스레드로 하여금 하나의 작업을 처리
    - 장점
        - 자원의 효율성 증대
            - 프로세스를 사용하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능
        - 처리 비용 감소
            - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모 감소
            - 스레드 사이의 작업량이 작아 Context Switching이 빠름
            - 빠른 응답 속도 기대 가능
        - 간단한 통신 방법을 통한 응답 시간 단축
            - 스레드는 프로세스 내 stack 영역을 제외한 모든 메모리 공유로, 통신 부담이 적음
    - 단점
        - 동기화 문제
            - 여러 스레드가 함께 전역 변수를 사용할 경우 발생할 수 있는 충돌
        - 하나의 스레드에서 문제 발생시 전체 프로세스 영향
        - 디버깅의 어려움

Topic 관련 예상 질문
- Process vs Thread
- Multi Process
- Multi Thread
- Context Switch
- Thread Safe
- ...


Reference
- https://brunch.co.kr/@babosamo/100
- https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html
- https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4
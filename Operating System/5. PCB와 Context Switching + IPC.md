# 0. PCB
- CPU는 각 프로세스들이 누군지 알아야 관리가 가능하다. 이 프로세스들의 특징을 갖고있는 것이 바로 `Process Metadata` 이다.

- Process Metadata
    - Process ID
    - Process State
    - Process Priority
    - CPU Registers
    - Owner
    - CPU Usage
    - Memeory Usage
    
이 메타데이터는 프로세스가 생성되면 `PCB(Process Control Block)`이라는 곳에 저장됨

#### PCB(Process Control Block)란?

> 프로세스 메타데이터들을 저장해 놓는 곳, 한 PCB 안에는 한 프로세스의 정보가 담김

<img src="https://t1.daumcdn.net/cfile/tistory/25673A5058F211C224" width="400">

##### 다시 정리해보면?

```
프로그램 실행 → 프로세스 생성 → 프로세스 주소 공간에 (코드, 데이터, 스택) 생성 
→ 이 프로세스의 메타데이터들이 PCB에 저장
```

<br>

##### PCB가 왜 필요한가요?

> CPU에서는 프로세스의 상태에 따라 교체작업이 이루어진다. (interrupt가 발생해서 할당받은 프로세스가 waiting 상태가 되고 다른 프로세스를 running으로 바꿔 올릴 때)
>
> 이때, **앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해두는 것**이다.

##### PCB는 어떻게 관리되나요?

> Linked List 방식으로 관리함
>
> PCB List Head에 PCB들이 생성될 때마다 붙게 된다. 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이함.
>
> 즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료시 제거됨

<br>


# 1. Context Switching

## 0. 프로세스의 문맥(Context)이란?
프로세스란 실행중인 프로그램을 말한다.

- 프로세스의 문맥(Context)
    - CPU 수행 상태를 나타내는 하드웨어 문맥
        - Program Counter
        - 각종 register
    - 프로세스의 주소 공간
        - code, data, stack
    - 프로세스 관련 커널 자료 구조
        - PCB(Process Control Block)
        - Kernal stack

프로세스의 문맥은 **"현재 상황"을 의미**한다. 프로세스는 CPU를 가지고 instruction을 실행하는데, 어디까지 실행했는지를 알기 위해서 레지스터에는 어떤 값을 넣었고, Program Counter는 어디를 가르키는지 알아야한다.

        
## 1. 문맥 교환(Context Switch)
- CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정

![](https://i.imgur.com/JR74Y9N.png)

> CPU를 빼앗기는 프로세스는 나중에도 다시 CPU를 차지할 수 있는 가능성이 있다. 즉, 현재 상태에서 CPU를 빼앗기더라도 어디까지 작업을 수행했는지 기억 해야할 필요가 있다는 것이다.
> 
> 예를 들어 1번부터 100번까지 쭉 써내려가는 작업이 있다고 해보자. 30번까지 쓰고 있었는데 CPU를 뺏겼다가 조금 후에 다시 CPU를 점유해서 작업을 시작해야 하는데 어디서부터 시작해야 할 지 모를 수 있다.
> 이러한 문제를 방지하기 위해 문맥 교환이 일어날 때는 CPU를 빼앗기는 프로세스의 상태를 해당 프로세스의 PCB에 저장한다. 그렇다면 새로 CPU를 얻는 프로세스의 경우도 마찬가지로 이전에 PCB를 저장했을 것이기 때문에, 프로세스의 상태를 PCB에서 읽어와서 작업을 진행한다.

- 주의할 점
    - 시스템 콜이나 인터럽트 발생 시 반드시 context switch가 일어나는 것은 아니다.

![](https://i.imgur.com/vtv8sHr.png)


- system call이나 interrupt 발생시 user mode에서 kernel mode로 간다고 context switch가 발생하지는 않는다. kernel mode에서 다시 user mode로 올 때 context switch 없이 변경되는 것이다.
- 하지만 무조건적으로 context switch가 일어나지 않는다고는 보기 어려운 상황도 있다. 예를 들어 A 사용자 프로세스를 처리하고 kernel mode에 들어갔으나, 다른 B 프로세스에게 다시 CPU를 넘겨주는 상황도 있을 수 있다. 이 때는 context switch가 일어나게 된다.
        

# 2. IPC(Inter-Process-Communication)
![](https://i.imgur.com/MAaj3wR.png)

프로세스는 독립적으로 실행된다. 즉, 다른 프로세스에게 영향을 받지 않는다는 것이다. (스레드는 프로세스 안에서 자원을 공유하므로 영향을 받는다)

이런 독립적 구조를 가진 프로세스 간의 통신을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 **IPC 통신**이다.

프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다. 

- ## IPC 종류
    - ### PIPE (익명 PIPE)
        - 파이프가 두 개의 프로세스를 연결한다.
        - **하나의 프로세스는 데이터를 쓰기만, 다른 하나는 데이터를 읽기만 할 수 있다.** 
        - 한쪽 방향으로만 통신이 가능한 파이프의 특징 때문에 **반이중 통신**이라고 부르기도 한다.
        - 부모프로세스가 자식 프로세스를 생성하는 경우에 파일 지정 번호를 상속받아 익명파이프로 통신을 할 수 있다. (형제 관계도 가능)
        - PIPE와 같은 반이중 통신의 경우 하나의 통신선로는 읽기나 쓰기 중 하나만 가능하므로 만약 읽기와 쓰기, 즉 송/수신을 모두 하기를 원한다면 **두개의 파이프를 만들어야 한다.**
        - PIPE는 매우 간단하게 사용할 수 있다는 장점이 있다.
            - 만약 한쪽 프로세스가 단지 읽기만 하고 다른 쪽 프로세스는 단지 쓰기만 하는, 단순한 데이터 흐름을 가진다면 고민 없이 PIPE를 사용하면 된다. 
        - 단점은 반이중 통신이라는 점으로 만약 프로세스가 읽기와 쓰기 통신 모두를 해야 한다면 PIPE를 두개 만들어야 하는데, 구현이 복잡해 질 수 있다. 
            - 만약 전이중 통신을 고려해야될 상황이라면 PIPE는 좋은 선택이 아니라고 보여진다.
    - ### Named PIPE(FIFO)
        - **익명 PIPE**는 통신할 프로세스를 명확히 알 수 있는 경우에 사용한다. (부모-자식 프로세스 간 통신처럼)
        - 익명파이프는 부모와 자식프로세스간의 통신만 가능하기 때문에, 외부 프로세스와 통신을 하기 위해서 파이프에 이름을 붙여주자는 생각으로 네임드 파이프가 등장했다.
        - 하지만 Named PIPE는 **전혀 모르는 상태의 프로세스들 사이의 통신에 사용**한다.
        - 즉, 익명 PIPE의 확장된 상태로 부모 프로세스와 무관하게 전혀 다른 모든 프로세스들 사이에서 통신이 가능한 것이다. 
            - 그 이유는 프로세스 통신을 위해 **이름이 있는 파일**을 사용하기 때문이다. 
        - 하지만 Named PIPE 역시 읽기/쓰기가 동시에 불가능해서 전이중 통신을 위해서는 익명 PIPE처럼 **파이프를 2개 만들어야 가능함**
    - ### Message Queue
        - 입출력 방식은 Named PIPE와 동일하다. 
            - 허나, 다른 점은 **Named PIPE가 데이터의 흐름이라면  Message Queue는 메모리 공간**이다.
        - 파이프가 아니라 어디에서나 물건을 꺼낼 수 있는 컨테이너 벨트라고 보면 된다. 
        - 메시지 큐의 장점은 컨테이너 벨트가 가지는 장점을 그대로 가지게 된다. 컨테이너 벨트에 올라올 물건에 라벨을 붙이면 동시에 다양한 물건을 다룰 수 있는 것과 같이 메시지 큐에 쓸 데이터에 번호를 붙임으로써 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다. 
    - ### Shared Memory(공유 메모리)
        - 데이터를 공유하는 방법에는 크게 두 가지가 있다. 하나는 통신을 이용해서 데이터를 주고 받는 것이고 다른 하나는 **데이터를 아예 공유, 즉 함께 사용하는 것**이다. 
        - 파이프, 메시지 큐가 통신을 이용한 설비라면, 공유 메모리는 데이터 자체를 공유하도록 지원하는 설비이다.
        
        > 프로세스의 메모리 영역은 독립적으로 가지며 다른 프로세스가 접근하지 못하도록 반드시 보호되야한다. 하지만 다른 프로세스가 데이터를 사용하도록 해야하는 상황도 필요할 것이다. 파이프를 이용해 통신을 통해 데이터 전달도 가능하지만, 스레드처럼 메모리를 공유하도록 해준다면 더욱 편할 것이다.
        
        - 공유 메모리는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용해준다.
        - 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다.
            - 중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 **가장 빠르게** 작동함
    - ### Memory Map
        - Shared Memory(공유메모리)공간과 마찬가지로 메모리를 공유한다는 측면에 있어서는 서로 비슷한 측면이 있다.
        - 차이점은 Memory Map의 경우 **열린파일을 메모리에 맵핑시켜서, 공유**한다는 점이다.
            - 파일은 시스템의 전역적인(모두 공유할 수 있는) 자원이므로 서로 다른 프로세스들끼리 데이터를 공유하는데 문제가 없을 것임을 예상할 수 있다.
        - 주로 파일로 대용량 데이터를 공유해야 할 때 사용한다.
    - ### Socket(소켓)
        - 네트워크 소켓 통신을 통해 데이터를 공유한다.
        - 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.
- 통신 가능 범위
    - Socket만 동일 시스템+ 외부 시스템, 나머지 방식은 모두 동일 시스템 내부

이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용한다. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)
> 프로세스간 메시지 전송을 하거나, 혹은 Shared Memory를 통해서 특정 데이타를 공유하게 될 경우 발생하는 문제가 공유된 자원에 여러개의 프로세스가 동시에 접근하면 안되며, 단지 한번에 하나의 프로세스만 접근 가능하도록 만들어줘야 할 것이며, 이 때 사용되는 것이 Semaphore이다.


---
#### 참고 링크

- [IPC](https://jwprogramming.tistory.com/54)
- [IPC](https://doitnow-man.tistory.com/110)
- [반효경 교수님 강의 - Process1](http://www.kocw.net/home/search/kemView.do?kemId=1046323)
